---
title: "Análisis del volumen operado de GD30 como serie de tiempo"
author: "Lisandro Carrasco"
date: "2022-12-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introducción

El bono soberano GD30 es el activo de renta fija más operado en la Argentina en los últimos tiempos. Este bono global de la República Argentina se caracteriza por ser el más utilizado para hacer una operación que resulta en la compra de divisas, conocidad como dolar MEP o Cable. 
La posibilidad de comprar el bono GD30 en pesos y venderlo como GD30D (MEP) o GD30C (Cable) para hacerse de dólares evitando cualquier límite regulatorio, popularizó su uso entre un enorme porcentaje de los operadores del mercado argentino, desde pequeños y medianos ahorritas hasta grandes empresas. De hecho, dado que el pago de intereses por la tenencia de este bono es muy bajo (así como muchos economistas descuentan que el bono será reestructurado a la brevedad), prácticamente el único incentivo que presenta la compra o tenencia de este bono es hacerse de dólares. 
Esta gran participación de usuarios del mercado y su volumen diario lo hacen uno de los más representativos del mercado de bonos local. 
En este trabajo, se busca observar el comportamiento de ese volumen operado, tratando de entender sus componentes como una serie temporal, explorando si hay estacionalidad en sus movimientos y evaluando técnicas de predicción en el tiempo. 


Para esto, vemos a trabajar con dos tipos de modelos:

* ARIMA
* Prophet

## Datos y librerías

Los datos del volumen operado de un bono se pueden obtener de la mayoría de las páginas webs de las sociedades bursátiles argentinas. En este caso, se obtiene un .csv de la web de [Rava Bursátil](https://www.rava.com/perfil/gd30) con los datos de cotización y volumen negociado del bono para cada día desde su emisión. 

Para el procesamiento de datos y el análisis de la serie de tiempo, se utiliza:¿n las siguientes librerías: 


```{r librerias, echo = FALSE}
library(dplyr)
library(ggplot2)
library(prophet)
library(lubridate)
library(readxl)
library(tsibble)
library(forecast)
library(feasts)
library(tidymodels)
library(modeltime)
library(fabletools)
library(fable)
```

## ARIMA

ARIMA es un modelo estadístico utilizado para analizar y modelar series de tiempo. Sus siglas corresponden a "Autoregressive Integrated Moving Average" y, como lo indica su nombre, pertenece a la familia de los modelos autoregresivos. La autoregresión y la media móvil son los dos componentes que se utilizan para modelar una serie de tiempo en un modelo ARMA, pero la "I" de ARIMA corresponde a un tercer componente de "integración". 

* Autoregresión: es el componente que apunta a que se puede formular una regresión (similar a un modelo lineal generalizado, pero no propiamente) que permita predecir el valor presente o futuro de una variable dependiente en función de sus propios valores anteriores. 
* Integración: es una operación que se lleva adelante para convertir a las series en estacionarias (es decir, con una media y varianza constante). La diferencia entre ARMA y ARIMA radica en esta integración, que permite mejorar la capacidad predictiva del modelo ante series de tiempo no estacionales y con variaciones no lineales.  
* Media móvil: es la forma de calcular el promedio sobre una cierta cantidad de valores pasados de la variable en cuestión. 

## Prophet

Por su parte, Prophet es un modelo desarrollado por la empresa Facebook y pertenece a la familia de los modelos aditivos generalizados (GAM). Una de las ventajas que presenta Prophet es que permite incluir en el modelado la detección de anomalías en la serie de tiempo, para controlar eventos inesperados. Prophet también permite hacer una descomposición de la serie de tiempo, considerando la estacionalidad del fenómeno en diferentes niveles de tiempo, así como obtener la tendencia general. 

## Descomposición de la serie de tiempo



* Tendencia general. 

* Variación estacional.

* Ruido blanco. 

```{r}

data <- read.csv('C:/Users/lisan/OneDrive/Escritorio/MAESTRIA/EEA/TP-2/eea/TP-2/bono.csv') %>%
  select(ds = fecha, y = volumen) %>% 
  mutate(ds = as.Date(ds)) %>% 
  filter(ds > '2020-10-01' & ds < '2022-12-01') %>% 
  group_by(ds = floor_date(ds, unit = "week")) %>% 
  summarise(y = mean(y, na.rm = TRUE)) %>% 
  as_tsibble(index = ds)

```

```{r}

plot(decompose(ts(data$y, frequency = 52)))

```

En este gráfico podemos observar 4 sub-graficos:

Observed: los datos actuales
Trend: el movimiento general hacia arriba o hacia abajo de los puntos de datos
Seasonal: cualquier patrón mensual / anual de los puntos de los datos
Random – parte inexplicable de los datos



## Análisis exploratorio

### Visualización


### Linealidad

Como se expresó anteriormente, la incorporación del componente de integración de ARIMA permite mejorar la capacidad predictiva ante series de tiempo con patrones de variación no lineales. Para evaluar si una serie de tiempo es o no estacionaliria y la linealidad de su comportamiento .

Una primer forma de aproximación a evaluar la linealidad o no de una serie de timepo, es mediante la exploración visual. 

```{r grafico uno}
autoplot(data)
```

Si bien una primera aproximación visual permite ver que no hay una linealidad muy marcada y que, por el contrario, a mitad de 2022 se ve un salto importante en el comportamiento de la serie temporal, esta visualización no es estrictamente suficiente para corrobonar la linealidad o no de la serie. Como se verá más adelante, este cambio brusco puede beneficiar a Prophet en términos de su capacidad predictiva. 
Una aproximación más estadística para este problema se puede realizar a partir de la autocorrelación. 

### Autocorrelación

La autocorrelación es una medida estadística que se utiliza para evaluar la relación entre los valores de una serie de tiempo y los diferentes puntos en el tiempo. Un valor de autocorrelación cercano a 1, indica una alta correlación entre los valores de la siere de tiempo (lo que puede indicar que se trata de una serie de tiempo con un patrón de variación no lineal); mietras que un valor cercano a 0 indica baja correlacióny un posible patrón lineal. 

```{r autocorrelacion}
acf(data,type = "correlation", na.action = na.pass )
```

### Estacionalidad

```{r}
data %>%
  gg_season(labels = "both", na.rm = TRUE) +
  labs(y = "Volumen", x = "Día",
       title = "Volumen operado GD30")

```

## Predicción

### ARIMA

Dado que vimos la no linealidad, vamos a utilizar un modelo auto arima. Utilizaremos las observaciones diarias. 

```{r}
data <- read.csv('C:/Users/lisan/OneDrive/Escritorio/MAESTRIA/EEA/TP-2/eea/TP-2/bono.csv') %>%
  select(ds = fecha, y = volumen) %>% 
  mutate(ds = as.Date(ds))
```


```{r pressure, echo=FALSE}

splits_arima <- initial_time_split(
  data = data, 
  prop = 0.8)

arima <- arima_reg() %>% 
  set_engine('auto_arima') %>% 
  fit(y~ds, data = training(splits_arima))

arima_tabla <- modeltime_table(arima)
arima_tabla <- arima_tabla %>%
    modeltime_calibrate(new_data = testing(splits_arima))


```

```{r}
arima_tabla %>% 
  modeltime_accuracy()
```

```{r}
arima_forecast <- arima_tabla %>% 
 modeltime_forecast(
    new_data    = testing(splits_arima),
    actual_data = data
 )

arima_forecast %>% 
  plot_modeltime_forecast(
    .legend_max_width = 30, 
    .interactive      = TRUE,
    .conf_interval_alpha = 0.2, 
    .line_size=0.2
    )
```

### Prophet

```{r pressure, echo=FALSE}
prophet = prophet()
prophet=add_seasonality(m=prophet, name='monthly', period=365/12, fourier.order = 4)

prophet = fit.prophet(m = prophet, data) 
plot(prophet,fcst=predict(prophet, data)) +theme_bw()
```

```{r}
prophet_plot_components(prophet, fcst=predict(prophet, data))
```


```{r}
cv_base = cross_validation(prophet, initial = 45, period = 7, horizon = 15, units = 'days')
```


#### Complejizando el modelo



```{r pressure, echo=FALSE}
eventos = data.frame(
  holiday= 'eventos',
  ds= ymd(c('2021-09-13','2021-11-15','2022-02-01',
                        '2022-07-04','2022-07-28')),
  lower_window= 0,
  upper_window= 0)

glimpse(eventos)
```


```{r pressure, echo=FALSE}
prophet_full=prophet(holidays = eventos)

prophet_full=add_seasonality(prophet_full, name='monthly', period=30.5, fourier.order = 4)
prophet_full = fit.prophet(m = prophet_full, data_dia)
```
```{r}
plot(prophet_full,fcst=predict(prophet_full, data_dia)) +theme_bw()
```


## Prediccion

```{r}
prophet_forecast <- prophet_reg(mode='regression') %>%
  set_engine('prophet')%>% 
  fit(y~ds, data = training(splits_arima))

prophet_forecast


```

```{r}
prophet_forecast %>% 
  modeltime_table() %>% 
  modeltime_calibrate(new_data=testing(splits_arima)) %>% 
  modeltime_accuracy()
```

